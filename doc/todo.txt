TODOs:
 o Do math functions for double/float properly
 o Fix bug where residuals are 0 at beginning.
 o Add templates instead of typedef real float...
 o Write proper Makefiles
 o Check whether is necessary to static_cast<real>(1) and so
   on... (compile time cast!!)
 o Do sanity check before creating the prox operators (don't allocate
   stuff inside the constructor)
 o Test Moreau prox
 
 o Lifted TV stereo example
 o Epigraph prox, continuous relaxation
 o Add LinearOperator class, for now only LinearOperatorSparseMatrix,
   maybe LinearOperatorZero (cudaMemset) and LinearOperatorIdentity (cudaMemcpy). 
 o Write helper functions for interleaved index calculation and
   double=>real conversion
 o Write proper error handling/checking code, with exceptions and have
   meaningful error messages. Have DEBUG mode, which outputs lots of information.
 o Resolve all TODOs in code
 o Implement debug/verbose flag where solver outputs lots of stuff
 o Write CMakeLists.txt and pdsolver_build.m properly so it builds
   nicely everywhere
 o Check coding style with lint
 o Investigate why everything crashes when MATLAB GUI is on but works
   with console
 o Reference MATLAB implementation of backends/proxs for debugging?
 o run with valgrind/cuda-memcheck/cuda-gdb to check for memleaks
 o Check for Memory Leaks and Out-Of-Bounds accesses in CUDA kernels.
 o Add doxygen comments
 o -Werror, -Wall compiler flags
 o Unit tests for prox operators, etc
 o Check how fast a naive multi-GPU sparse/matrix vector product is,
   add multi-GPU support if slowdown isn't too large. Multi-GPU support
   requires refactoring of most parts of the library... maybe have
   something like a Vector-class or OptimVariable-class which resides
   on several GPUs and the LinearOperator and ProximalOperator class
   can act on it. It should also support basic operations like adding,
   scaling, reductions, etc.
   If everything has to get refactored anyways, one might consider
   also adding CPU support. Check how switching between CPU/GPU works
   e.g. in Caffe. Also check how Multi-GPU support works in Caffe.
 o Graph Projection Splitting backend with indirect CG solver
   (e.g. CGLS).
 o Python/C/C++ bindings
 o Implement some example problems
 o Inertial/overrelaxed primal-dual? 
 o Look into matrix equilibriation preconditioner, constrained
   equilibriation
 o Subgradient projection for initialization?!

Done:
 x Lifted TV rof denoising example
 x Adapt to google C++ style guide
 x MATLAB callback, output primal-dual gap in ex_rof.m
 x Output Memory Requirement for Solver
 x Diagonal Preconditioner Options (off/on/equilibration), only "off" for now
 x ProxNorm2 is broken, fix it
 x Test with double precision
 x Adaptive Steps for PDHG backend
 x Simplex Projection prox (not useful due to limited shared memory)
 x Diagonal Preconditioning a la Pock
 x Add check if prox operators cover the whole primal/dual domain
 x Stopping Criterion?

Ideas of cool Prox-Operators to implement:
 o huber, identity, 0 <= x <= 1, x <= 0, max(0, x), pogs
 o check Combettes papers
 o q>1, elastic net
 o constraint sets from lifting papers
 o nuclear norm
 o x^T A x + b^T x + c
 o second order cone projection
 o halfspace projection
 o linear operator (1/2) ||Ax-b||^2 with cuFFT
 o linear operator (preconditioned) conjugate gradient
 o elastic net
 o projection onto epigraph of x^T A x + b^T x + c?
 o l_infty norms, full l1 ball
 o general function of singular values?
 o mixed matrix norms
 o (nonconvex nuclear norm)
 o (l^q (0<=q<infty) 1d, nuclear & 2-norm)
 o (mumford-shah 1d & 2-norm)
 o (smooth (semiconvex) mumford-shah 1d & 2-norm)
 o ...?
 
